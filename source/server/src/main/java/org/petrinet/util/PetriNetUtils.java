package org.petrinet.util;

import org.petrinet.client.*;
import org.petrinet.service.model.Arc;
import org.petrinet.service.model.Place;
import org.petrinet.service.model.Transition;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Utility class containing shared logic for Petri net operations across different services.
 * This class consolidates common functionality such as state signature creation, deep copying,
 * DTO conversion, and utility methods to reduce code duplication.
 */
public class PetriNetUtils {

    /**
     * Creates a deterministic string signature for a given Petri net state based on its token distribution.
     * The signature is generated by concatenating 'placeId:tokenCount' pairs, sorted alphabetically
     * by place ID to ensure the signature is deterministic regardless of the order of places in the list.
     * This signature is used for detecting repeated states (infinite loops).
     *
     * @param state The {@link PetriNetDTO} representing the current state of the Petri net.
     * @return A deterministic string signature of the state's token distribution (e.g., "p1:1,p2:0,p3:2"),
     *         or an empty string if the state or its places list is null.
     */
    public static String createStateSignature(PetriNetDTO state) {
        if (state == null || state.getPlaces() == null) {
            return "";
        }
        return state.getPlaces().stream()
            .filter(Objects::nonNull)
            .sorted(Comparator.comparing(PlaceDTO::getId))
            .map(place -> place.getId() + ":" + place.getTokens())
            .collect(Collectors.joining(","));
    }

    /**
     * Creates a deep copy of a PetriNetDTO.
     * This is essential to prevent modifications to the original data during simulation.
     *
     * @param original The original {@link PetriNetDTO} to copy.
     * @return A new {@link PetriNetDTO} instance representing a deep copy.
     */
    public static PetriNetDTO createDeepCopy(PetriNetDTO original) {
        List<PlaceDTO> places = original.getPlaces().stream()
            .map(p -> new PlaceDTO(p.getId(), p.getTokens(), p.isBounded(), p.getCapacity()))
            .collect(Collectors.toList());
            
        List<TransitionDTO> transitions = original.getTransitions().stream()
            .map(t -> new TransitionDTO(t.getId(), t.getEnabled(), new ArrayList<>(t.getArcIds())))
            .collect(Collectors.toList());
            
        List<ArcDTO> arcs = original.getArcs().stream()
            .map(a -> new ArcDTO(a.getId(), a.getType(), a.getIncomingId(), a.getOutgoingId()))
            .collect(Collectors.toList());
            
        PetriNetDTO copy = new PetriNetDTO(places, transitions, arcs);
        copy.setDeterministicMode(original.getDeterministicMode());
        return copy;
    }

    /**
     * Creates a deep copy of the Petri net structure from a validation request DTO.
     * This is essential to prevent the simulation from modifying the original data sent by the client.
     *
     * @param requestDTO The {@link PetriNetValidationDTO} containing the original Petri net definition.
     * @return A new {@link PetriNetDTO} instance representing a deep copy of the places,
     *         transitions, and arcs from the request DTO.
     */
    public static PetriNetDTO createDeepCopyFromValidation(PetriNetValidationDTO requestDTO) {
        // Copy places
        List<PlaceDTO> placesCopy = requestDTO.getPlaces().stream()
            .map(p -> new PlaceDTO(
                p.getId(),
                p.getTokens(),
                p.isBounded(),
                p.getCapacity()
            ))
            .collect(Collectors.toList());
        
        // Copy transitions
        List<TransitionDTO> transitionsCopy = requestDTO.getTransitions().stream()
            .map(t -> {
                // Ensure arcIds list is mutable for potential modifications if needed elsewhere
                List<String> arcIdsCopy = t.getArcIds() == null ? new ArrayList<>() : new ArrayList<>(t.getArcIds());
                TransitionDTO copy = new TransitionDTO(t.getId(), t.getEnabled(), arcIdsCopy);
                return copy;
            })
            .collect(Collectors.toList());
        
        // Copy arcs
        List<ArcDTO> arcsCopy = requestDTO.getArcs().stream()
            .map(a -> new ArcDTO(a.getId(), a.getType(), a.getIncomingId(), a.getOutgoingId()))
            .collect(Collectors.toList());
        
        // Create new Petri net DTO with copied components
        PetriNetDTO copy = new PetriNetDTO(placesCopy, transitionsCopy, arcsCopy);
        return copy;
    }

    /**
     * Converts domain models back to a PetriNetDTO.
     * This method maps internal {@link Place}, {@link Transition}, and {@link Arc} representations 
     * to their respective DTOs and preserves the deterministic mode flag from the original request.
     *
     * @param placesMap A map of place IDs to {@link Place} domain models.
     * @param transitions A list of {@link Transition} domain models (potentially with updated 'enabled' status).
     * @param arcsMap A map of arc IDs to {@link Arc} domain models.
     * @param originalDTO The original DTO passed to the service method, used to retrieve the deterministic mode flag.
     * @return A new {@link PetriNetDTO} representing the current state derived from the domain models.
     */
    public static PetriNetDTO convertDomainModelsToDTO(Map<String, Place> placesMap, 
                                                      List<Transition> transitions,
                                                      Map<String, Arc> arcsMap, 
                                                      PetriNetDTO originalDTO) {
        List<PlaceDTO> placeDTOs = placesMap.values().stream()
            .map(place -> new PlaceDTO(
                place.getId(),
                place.getTokens(),
                place.isBounded(),
                place.getCapacity()
            ))
            .collect(Collectors.toList());

        List<TransitionDTO> transitionDTOs = transitions.stream()
            .map(transition -> new TransitionDTO(
                transition.getId(),
                transition.getEnabled(),
                transition.getArcIds()))
            .collect(Collectors.toList());

        List<ArcDTO> arcDTOs = arcsMap.values().stream()
            .filter(Objects::nonNull)
            .map(arc -> {
                String type = switch (arc) {
                    case Arc.RegularArc regularArc -> "REGULAR";
                    case Arc.InhibitorArc inhibitorArc -> "INHIBITOR";
                    case Arc.BidirectionalArc bidirectionalArc -> "BIDIRECTIONAL";
                };
                return new ArcDTO(arc.getId(), type, arc.getIncomingId(), arc.getOutgoingId());
            })
            .collect(Collectors.toList());

        PetriNetDTO newDTO = new PetriNetDTO(placeDTOs, transitionDTOs, arcDTOs);
        
        if (originalDTO != null) {
            newDTO.setDeterministicMode(originalDTO.getDeterministicMode());
        }
        return newDTO;
    }

    /**
     * Applies the initial token configuration to the places in the provided Petri net.
     * First, all places in the net are reset to have 0 tokens. Then, tokens are added
     * according to the provided input configurations.
     *
     * @param petriNet The {@link PetriNetDTO} whose places will be initialized. This object is modified directly.
     * @param inputConfigs A list of {@link PetriNetValidationDTO.PlaceConfig} specifying the initial
     *                     token counts for certain places. Places not listed remain at 0 tokens.
     */
    public static void applyInputTokens(PetriNetDTO petriNet, List<PetriNetValidationDTO.PlaceConfig> inputConfigs) {
        // Reset all places to 0 tokens first
        petriNet.getPlaces().forEach(p -> p.setTokens(0));
        
        // Map places by ID for easier lookup
        Map<String, PlaceDTO> placesById = petriNet.getPlaces().stream()
            .collect(Collectors.toMap(PlaceDTO::getId, p -> p));
        
        // Apply token counts from input configurations
        for (PetriNetValidationDTO.PlaceConfig input : inputConfigs) {
            PlaceDTO place = placesById.get(input.getPlaceId());
            if (place != null) {
                place.setTokens(input.getTokens());
            }
        }
    }

    /**
     * Finds the index of a place in a list by its ID.
     *
     * @param places The list of places to search in.
     * @param placeId The ID of the place to find.
     * @return The index of the place if found, -1 otherwise.
     */
    public static int findPlaceIndex(List<PlaceDTO> places, String placeId) {
        for (int i = 0; i < places.size(); i++) {
            if (places.get(i).getId().equals(placeId)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Finds the index of a transition in a list by its ID.
     *
     * @param transitions The list of transitions to search in.
     * @param transitionId The ID of the transition to find.
     * @return The index of the transition if found, -1 otherwise.
     */
    public static int findTransitionIndex(List<TransitionDTO> transitions, String transitionId) {
        for (int i = 0; i < transitions.size(); i++) {
            if (transitions.get(i).getId().equals(transitionId)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Calculates the total number of tokens across all places in a Petri net.
     *
     * @param petriNet The Petri net to calculate total tokens for.
     * @return The total number of tokens across all places.
     */
    public static long calculateTotalTokens(PetriNetDTO petriNet) {
        return petriNet.getPlaces().stream()
            .mapToLong(PlaceDTO::getTokens)
            .sum();
    }
} 